golang的切片(slice)是一种比较特殊的数据结构，切片是围绕动态数组的概念构建，按需自动扩大和缩小。切片的底层是在连续的内存块中分配，它对底层的数组进行了抽象。它是一个有三个字符的数据结构。地址指针，长度，容量。不可以创建容量小于长度的切片！
切片共享底层数组的切片，两个切片 b 和 c 共享同一个(a)底层数组。如果一个切片修改了该底层数组的共享
部分，另一个切片也能感知到。go在append的时候放大cap是有规律的。在 cap 小于1024的情况下是每次扩大到 2 * cap ，当大于1024之后就每次扩大到 1.25 * cap。
讲了一堆大道理，看多了也迷糊。我们例了小例子。

```golang
arr := []int{0, 1, 2, 3, 4, 5, 6, 7, 8}
s1 := arr[2:6] //2,3,4,5
fmt.Println("s1", s1)
s2 := s1[1:3] //3,4
fmt.Println("s2", s2)
```
以上代码的输出结果很容易吧，最后出应是 
s1：2，3，4，5
s2：3,4

```golang
arr := []int{0, 1, 2, 3, 4, 5, 6, 7, 8}
s1 := arr[2:6] //2,3,4,5
s2 := s1[1:3] //3,4
s3 := s1[4:5]
fmt.Println("s3", s3)
//这里的s3会输出什么呢？？会报错吗？
```
你觉得s3 会是 报错？？0,0？？我们当时s1是取arr[2:6],s1是2，3，4，5 那我们这里的s3想取s1的从第四到第五前面，好像长度根本都不够！！！
不要着急，其实s1的底层数组是 2，3，4，5，6，7，8 这里我们取s1[4:5], 结果是6

我们再来看一下切片的具体变化

arr := []int{0, 1, 2, 3, 4, 5, 6, 7, 8}
s1 := arr[2:6] //2,3,4,5 （底层是 2，3，4，5， **6，7，8**）
s2 := s1[1:3] //3,4 （底层是 3，4，**5，6，7，8**）
s3 := s1[4:5] // 6 （底层是 6，**7，8**）
s4 := s3[:2] // 6,7 （底层是 6，7，**8**）
fmt.Println("s4", s4)
s4 = append(s4, 9) //6,7,9 (底层发生变化)
fmt.Println("s4", s4)

我们可以使用len,与cap来进行观察